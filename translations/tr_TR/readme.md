# Tutarlı, Deyimsel JavaScript Yazma İlkeleri


## Bu yaşayan bir belgedir ve çevremizdeki kodları geliştirmek için yeni fikirler her zaman memnuniyetle karşılanır. Katkıda bulunun: fork, clone, branch, commit, push, pull request.

* Rick Waldron [@rwaldron](http://twitter.com/rwaldron), [github](https://github.com/rwaldron)
* Mathias Bynens [@mathias](http://twitter.com/mathias), [github](https://github.com/mathiasbynens)
* Schalk Neethling [@ossreleasefeed](http://twitter.com/ossreleasefeed), [github](https://github.com/ossreleasefeed/)
* Kit Cambridge  [@kitcambridge](http://twitter.com/kitcambridge), [github](https://github.com/kitcambridge)
* Raynos  [github](https://github.com/Raynos)
* Matias Arriola [@MatiasArriola](https://twitter.com/MatiasArriola), [github](https://github.com/MatiasArriola/)
* John Fischer [@jfroffice](https://twitter.com/jfroffice), [github](https://github.com/jfroffice/)
* Idan Gazit [@idangazit](http://twitter.com/idangazit), [github](https://github.com/idan)
* Leo Balter [@leobalter](http://twitter.com/leobalter), [github](https://github.com/leobalter)
* Breno Oliveira [@garu_rj](http://twitter.com/garu_rj), [github](https://github.com/garu)
* Leo Beto Souza [@leobetosouza](http://twitter.com/leobetosouza), [github](https://github.com/leobetosouza)
* Ryuichi Okumura [@okuryu](http://twitter.com/okuryu), [github](https://github.com/okuryu)
* Pascal Precht [@PascalPrecht](http://twitter.com/PascalPrecht), [github](https://github.com/pascalprecht)
* EngForDev [engfordev](https://opentutorials.org/course/245/1788) - Hwan Min Hong / MinTaek Kwon [@leoinsight](http://twitter.com/leoinsight) / Tw Shim [@marocchino](http://twitter.com/marocchino), [github](https://github.com/marocchino) / Nassol Kim [@nassol99](http://twitter.com/nassol99), [github](https://github.com/nassol) / Juntai Park [@rkJun](http://twitter.com/rkJun), [github](https://github.com/rkJun) / Minkyu Shim / Gangmin Won / Justin Yoo [@justinchronicle](http://twitter.com/justinchronicle) / Daeyup Lee
* Marco Trulla [@marcotrulla](http://twitter.com/marcotrulla), [github](https://github.com/Ragnarokkr)
* Alex Navasardyan [@alexnavasardyan](http://twitter.com/alexnavasardyan), [github](https://github.com/2k00l)
* Mihai Paun [@mihaipaun](http://twitter.com/mihaipaun), [github](https://github.com/mihaipaun)
* Evgeny Mandrikov [@\_godin\_](http://twitter.com/_godin_), [github](https://github.com/Godin)
* Sofish Lin [@sofish](http://twitter.com/sofish), [github](https://github.com/sofish)
* Дејан Димић [@dejan_dimic](http://twitter.com/dejan_dimic), [github](https://github.com/rubystream)
* Miloš Gavrilović [@gavrisimo](http://twitter.com/gavrisimo), [github](https://github.com/gavrisimo)
* Firede [@firede](https://twitter.com/firede) [github](https://github.com/firede)
* monkadd [github](https://github.com/monkadd)
* Stephan Lindauer [@stephanlindauer](http://twitter.com/stephanlindauer), [github](https://github.com/stephanlindauer)
* Thomas P [@dragon5689](https://twitter.com/dragon5689) [github](https://github.com/dragon5689)
* Yotam Ofek [@yotamofek](https://twitter.com/yotamofek) [github](https://github.com/yotamofek)
* Aleksandr Filatov [@greybax](http://twitter.com/greybax), [github](https://github.com/greybax)
* Duc Nguyen [@ducntq](https://twitter.com/ducntq), [github](https://github.com/ducntq)
* James Young [@jamsyoung](http://twitter.com/jamsyoung), [github](https://github.com/jamsyoung)
* Hao-Wei Jeng [@l0ckys](http://twitter.com/l0ckys), [github](https://github.com/lockys)  
* Richard Gibson [@gibson042](http://twitter.com/gibson042), [github](https://github.com/gibson042)  
* Fesuy [github](https://github.com/fesuydev)  
* Stephane Moreau [github](https://github.com/stmoreau)  
* Boris Nekezov [github](https://github.com/boris-nekezov)
* Akshat Joshi [@akshat_joshi](http://twitter.com/akshat_joshi), [github](https://github.com/akshatjoshii) 
* Coşkun Atak [@dimaetor](http://twitter.com/dimaetor), [github](https://github.com/Coskntkk) 

## Herhangi bir kod tabanındaki tüm kodlar, kaç kişi katkıda bulunursa bulunsun, tek bir kişinin yazdığı gibi görünmelidir.

### Aşağıdaki liste, orijinal yazarı olduğum tüm kodlarda kullandığım uygulamaları özetlemektedir; yarattığım projelere katkılar bu yönergeleri takip etmelidir.

### Stil tercihlerimi başkalarının kodlarına veya projelerine dayatmak niyetinde değilim; eğer mevcut bir ortak tarz varsa, buna saygı gösterilmelidir.


> ### "Tarz üzerindeki tartışmalar anlamsızdır. Bir stil rehberi olmalı ve onu takip etmelisin."
>_Rebecca_ _Murphey_

&nbsp;

> ### "Başarılı bir projenin iyi bir temsilcisi olmanın bir parçası da kendiniz için kod yazmanın Kötü Bir Fikir™ olduğunu anlamaktır. Binlerce kişi kodunuzu kullanıyorsa, kodunuzu spesifikasyon içinde nasıl akıllı olacağına dair kişisel tercihiniz değil, maksimum netlik için yazın."
>_Idan_ _Gazit_


## Çeviriler

* [Bulgarian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/bg_BG)
* [German](https://github.com/rwldrn/idiomatic.js/tree/master/translations/de_DE)
* [French](https://github.com/rwldrn/idiomatic.js/tree/master/translations/fr_FR)
* [Spanish](https://github.com/rwldrn/idiomatic.js/tree/master/translations/es_ES)
* [Portuguese - Brazil](https://github.com/rwldrn/idiomatic.js/tree/master/translations/pt_BR)
* [Korean](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ko_KR)
* [日本語](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ja_JP)
* [Italian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/it_IT)
* [Russian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ru_RU)
* [Romanian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ro_RO)
* [简体中文](https://github.com/rwldrn/idiomatic.js/tree/master/translations/zh_CN)
* [Serbian - cyrilic alphabet](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ср_СР)
* [Serbian - latin alphabet](https://github.com/rwldrn/idiomatic.js/tree/master/translations/sr_SR)
* [繁體中文](https://github.com/rwaldron/idiomatic.js/tree/master/translations/zh_TW)  
* [Indonesian](https://github.com/rwaldron/idiomatic.js/tree/master/translations/id_ID)  
* [Greek](https://github.com/rwaldron/idiomatic.js/tree/master/translations/gr_GR)
* [Hindi](https://github.com/rwaldron/idiomatic.js/tree/master/translations/hi_HI)
* [Turkish](https://github.com/rwaldron/idiomatic.js/tree/master/translations/tr_TR) 

## Önemli, Deyimsel Olmayan Şeyler:

### Kaliteli Kod İçim Araçlar, Kaynaklar & Referanslar

 * [SonarQube](https://www.sonarqube.org/)
 * [Plato](https://github.com/es-analysis/plato)
 * [jsPerf](http://jsperf.com/)
 * [jsFiddle](http://jsfiddle.net/)
 * [Codepen](http://codepen.io/)
 * [jsbin](http://jsbin.com/)
 * [JavaScript Lint (JSL)](http://javascriptlint.com/)
 * [jshint](http://jshint.com/)
 * [jslint](http://jslint.org/)
 * [eslint](http://eslint.org/)
 * [jscs](https://www.npmjs.org/package/jscs)
 * [jscodesniffer](https://www.npmjs.org/package/jscodesniffer)
 * [Editorconfig](http://editorconfig.org/)
 * [Hound](https://houndci.com/)

## Alını Kullan

### [Annotated ECMAScript 5.1](http://es5.github.com/)
### [EcmaScript Language Specification, 5.1 Edition](http://ecma-international.org/ecma-262/5.1/)

Aşağıdaki liste şu şekilde dikkate alınmalıdır: 1) tamamlanmamış, and 2) *OKUNMASI GEREKLİ*. Aşağıdaki yazarların üslubuna her zaman katılmıyorum, ancak kesin olan bir şey var: Tutarlılar. Ayrıca dil üzerinde otoriteler.

 * [Baseline For Front End Developers: 2015](https://rmurphey.com/posts/a-baseline-for-front-end-developers-2015/)
 * [Eloquent JavaScript](http://eloquentjavascript.net/)
 * [JavaScript, JavaScript](http://javascriptweblog.wordpress.com/)
 * [Adventures in JavaScript Development](http://rmurphey.com/)
 * [Perfection Kills](http://perfectionkills.com/)
 * [Douglas Crockford's Wrrrld Wide Web](http://www.crockford.com)
 * [JS Assessment](https://github.com/rmurphey/js-assessment)




### Hazırlanma ve Yayımlanma Süreci

Projeler, üretim kullanımına hazırlanırken her zaman kaynağın astarlanabileceği, test edilebileceği ve sıkıştırılabileceği bazı genel araçları dahil etmeye çalışmalıdır. Bu görev için Ben Alman tarafından yazılan [grunt](https://github.com/gruntjs/grunt) rakipsizdir ve resmi olarak bu deponun "kits/" dizininin yerini almıştır.




### Test Bölümü

Projeler bir tür birim, referans, uygulama veya işlevsel test _içermelidir_. Use case demos DO NOT QUALIFY as "tests". Aşağıda, hiçbiri diğerinden daha fazla desteklenmeyen frameworklerin bir listesi bulunmaktadır.

 * [QUnit](http://github.com/jquery/qunit)
 * [Jasmine](https://github.com/pivotal/jasmine)
 * [Vows](https://github.com/cloudhead/vows)
 * [Mocha](https://github.com/visionmedia/mocha)
 * [Hiro](http://hirojs.com/)
 * [JsTestDriver](https://code.google.com/p/js-test-driver/)
 * [Buster.js](http://busterjs.org/)
 * [Sinon.js](http://sinonjs.org/)
 * [Tape](https://github.com/substack/tape)
 * [Jest](https://facebook.github.io/jest/)

## İçindekiler

 * [Boşluk](#whitespace)
 * [Güzel Syntax](#spacing)
 * [Yazım Kontrolü (İncelikli jQuery Temel Stil Rehberleri)](#type)
 * [Koşullu Değerlendirme](#cond)
 * [Pratik Stil](#practical)
 * [İsimlendirme](#naming)
 * [Çeşitli](#misc)
 * [Yerel ve Ana Nesneler](#native)
 * [Yorumlar](#comments)
 * [Tek Dil Kod](#language)



------------------------------------------------


## Önsöz

Aşağıdaki bölümler, modern JavaScript geliştirme için bir _makul_ stil kılavuzunun ana hatlarını vermektedir ve kuralcı olması amaçlanmamıştır. En önemli çıkarım, **kod stili tutarlılığı yasasıdır**. Projeniz için stil olarak ne seçerseniz seçin yasa olarak kabul edilmelidir. Projenizin kod stili tutarlılığı, okunabilirliği ve sürdürülebilirliği konusundaki kararlılığının bir ifadesi olarak bu belgeye bağlantı verin.





## Deyimsel Stil Manifestosu


1. <a name="whitespace">Boşluk</a>
  - Asla boşluk ve tabları birlikte kullanmayın.
  - Bir projeye başlarken, hiçbir kod yazmadan önce, yumuşak satırbaşları (boşluklar) veya gerçek tablar arasından bir seçim yapın, bunu **kanun** olarak kabul edin.
      - Okunabilirlik için, Editörünüzün girinti boyutunu her zaman iki karakter &mdash; olarak ayarlamanızı öneririm. Bu, gerçek bir tabı temsil eden iki boşluk veya iki boşluk anlamına gelir.
  - Eğer editörünüz destekliyorsa, her zaman "show invisibles / görünmezleri göster" ayarını açık tutun. Bu uygulamanın faydaları şunlardır:
      - Zorunlu tutarlılık
      - Satır sonu boşluklarını ortadan kaldırma
      - Boş satır boşluklarını ortadan kaldırma
      - Okuması daha kolay olan eklemeler ve farklılıklar
  - Mümkün olduğunda [Düzenleyici yapılandırması](http://editorconfig.org/) kullanın.  It supports most IDEs and handles most whitespace settings.


2. <a name="spacing">Güzel Syntax</a>

    A. Parantezler, Süslü Parantezler, Satır sonları

    ```javascript

    // if/else/for/while/try her zaman boşlukla, parantez kullanılarak ve birden çok satıra yayılarak yazılır.
    // bu okunabilirliği artır

    // 2.A.1.1
    // Oldukça sıkışık syntax örnekkleri

    if(condition) doSomething();

    while(condition) iterating++;

    for(var i=0;i<100;i++) someIterativeFn();


    // 2.A.1.1
    // Okunabilirliği artırmak için boşluk kullanın

    if ( condition ) {
      // ifadeler
    }

    while ( condition ) {
      // ifadeler
    }

    for ( var i = 0; i < 100; i++ ) {
      // ifadeler
    }

    // Hatta daha iyisi:

    var i,
      length = 100;

    for ( i = 0; i < length; i++ ) {
      // ifadeler
    }

    // Veya...

    var i = 0,
      length = 100;

    for ( ; i < length; i++ ) {
      // ifadeler
    }

    var prop;

    for ( prop in object ) {
      // ifadeler
    }


    if ( true ) {
      // ifadeler
    } else {
      // ifadeler
    }
    ```


    B. Atamalar, Deklerasyonlar, Fonksiyonlar ( İsimli, İfade, Constructor )

    ```javascript

    // 2.B.1.1
    // Değişkenler
    var foo = "bar",
      num = 1,
      undef;

    // Değişmez gösterimler:
    var array = [],
      object = {};


    // 2.B.1.2
    // Tüm değişken grubu için tek bir `var` veya her bir değişken için bir `var` kullanmak
    // okunabilirliği artırır ve tanımlamalarınızı dağınıklıktan korur.
    // Her bir değişken için bir `var` kullanarak versiyonlarınız üzerinde daha fazla kontrol // //
    // sahibi olabilirsiniz ve satırları düzenlemeniz daha kolay olur.
    // Tüm değişken grubu için tek bir `var` kullanmak tanımlanmamış değişkenlerin tespit 
    // edilmesini kolaylaştırır.
    // Projeniz için daha iyi olanı seçin ve asla birlikte kullanmayın.

    // Kötü
    var foo = "",
      bar = "";
    var qux;

    // İyi
    var foo = "";
    var bar = "";
    var qux;

    // veya..
    var foo = "",
      bar = "",
      qux;

    // veya..
    var // İlgili yorumlar
    foo = "",
    bar = "",
    quux;

    // 2.B.1.3
    // var ifadeleri her zaman bulundukları alanın (fonksiyon) en başında olmalıdır.


    // Kötü
    function foo() {

      // bazı ifadeler

      var bar = "",
        qux;
    }

    // İyi
    function foo() {
      var bar = "",
        qux;

      // tüm ifadeler değişkenlerin tanımlanmasından sonra
    }

    // 2.B.1.4
    // ECMAScript 6'daki const ve let aynı şekilde her zaman bulundukları alanın (fonksiyon) en 
    // başında olmalıdır.

    // Kötü
    function foo() {
      let foo,
        bar;
      if ( condition ) {
        bar = "";
        // ifadeler
      }
    }
    // İyi
    function foo() {
      let foo;
      if ( condition ) {
        let bar = "";
        // ifadeler
      }
    }
    ```

    ```javascript

    // 2.B.2.1
    // İsimlendirilmiş Fonksiyonların Tanımlanması
    function foo( arg1, argN ) {

    }

    // Kullanım
    foo( arg1, argN );


    // 2.B.2.2
    // İsimlendirilmiş Fonksiyonların Tanımlanması
    function square( number ) {
      return number * number;
    }

    // Kullanım
    square( 10 );

    // Aynı stilin iç içe devam ettirilmesi
    function square( number, callback ) {
      callback( number * number );
    }

    square( 10, function( square ) {
      // callback ifadeleri
    });


    // 2.B.2.3
    // Fonksiyon Tanımlanması
    var square = function( number ) {
      // Değerli ve alakalı bir şeyin döndürülmesi
      return number * number;
    };

    // Identifier ile Fonksiyon Tanımlanması
    // Burada tercih edilen form, kendisini çağırabilmek ve bir değişken ismine sahip
    // olma gibi ek değerlere sahiptir.
    var factorial = function factorial( number ) {
      if ( number < 2 ) {
        return 1;
      }

      return number * factorial( number - 1 );
    };


    // 2.B.2.4
    // Constructor Tanımlanması
    function FooBar( options ) {

      this.options = options;
    }

    // Kullanım
    var fooBar = new FooBar({ a: "alpha" });

    fooBar.options;
    // { a: "alpha" }

    ```


    C. İstisnalar, Küçük Farklılıklar

    ```javascript

    // 2.C.1.1
    // Callback içeren fonksiyonlar 
    foo(function() {
      // Çağırılan 'foo' fonksiyonunun ilk parantezi ile tanımlanan isimsiz fonksiyonun 
      //'function' ifadesi arasında bir boşluk olmadığına dikkat edin.
    });

    // Bir array girdi alan fonskiyon, boşluk yok
    foo([ "alpha", "beta" ]);

    // 2.C.1.2
    // Bir obje girdi alan fonskiyon, boşluk yok
    foo({
      a: "alpha",
      b: "beta"
    });

    // Tek argüman string, boşluk yok
    foo("bar");

    // İfade parantezleri, boşluk yok
    if ( !("foo" in obj) ) {
      obj = (obj.bar || defaults).baz;
    }

    ```

    D. Tutarlılık Her Zaman Kazanır

    2.A-2.C bölümlerinde, boşluk kuralları, daha basit, daha yüksek bir amaca yönelik bir öneri olarak ortaya konmuştur: tutarlılık.
    "İç boşluk" gibi biçimlendirme tercihlerinin isteğe bağlı olarak değerlendirilmesi gerektiğini, ancak projenizin tüm kaynağında yalnızca bir stil bulunması gerektiğini unutmamak önemlidir.

    ```javascript

    // 2.D.1.1

    if (condition) {
      // ifadeler
    }

    while (condition) {
      // ifadeler
    }

    for (var i = 0; i < 100; i++) {
      // ifadeler
    }

    if (true) {
      // ifadeler
    } else {
      // ifadeler
    }

    ```

    E. Tırnak İşaretleri

    Tek ya da çift tırnağı tercih etmeniz önemli değil, Javascript için bunların hiçbir farkı yoktur. **KESİNLİKLE** uygulanması gereken şey tutarlılıktır. **Aynı projede asla tek ve çift tırnağı birlikte kullanmayın. Bir stil seçin ve ona bağlı kalın.**

    F. Satır Sonlar ve Boş Satırlar

    Boşluk, farkları mahvedebilir ve değişiklik setlerinin okunmasını imkansız hale getirebilir. Satır sonu boşluklarını ve boş satırlardaki boşlukları otomatik olarak kaldıran bir pre-commit hook eklemeyi düşünün.

3. <a name="type">Yazım Kontrolü (İncelikli jQuery Temel Stil Rehberleri)</a>

    A. Asıl Türler

    String:

        typeof variable === "string"

    Number:

        typeof variable === "number"

    Boolean:

        typeof variable === "boolean"

    Object:

        typeof variable === "object"

    Array:

        Array.isArray( arrayLikeObject )
        (wherever possible)

    Node:

        elem.nodeType === 1

    null:

        variable === null

    null veya undefined:

        variable == null

    undefined:

      Global Değişkenler:

        typeof variable === "undefined"

      Yerel Değişkenler:

        variable === undefined

      Özellikler:

        object.prop === undefined
        object.hasOwnProperty( prop )
        "prop" in object

    B. Zorlama Türler

    Aşağıdakilerin etkilerini düşünün...

    Bu HTML verildiğinde:

    ```html

    <input type="text" id="foo-input" value="1">

    ```


    ```javascript

    // 3.B.1.1

    // `foo` `0` değeri ile tanımlanmış ve türü `number`
    var foo = 0;

    // typeof foo;
    // "number"
    ...

    // Daha sonra kodunuzda bir yerde, `foo` değerini bir input elementinden
    // gelen yeni bir değer ile güncellemeniz gerekti.

    foo = document.getElementById("foo-input").value;

    // Eğer şimdi `typeof foo` ifadesini test edecek olursanız, sonuç `string` olurdu
    // Bu demek oluyor ki eğer `foo` test edilseydi:

    if ( foo === 1 ) {

      importantTask();

    }

    // `foo`, "1" (string) değerine sahip olsaydı bile `importantTask()` satırı asla çalışmazdı.


    // 3.B.1.2

    // Tekli + veya - operatörleriyle akıllı zorlama kullanarak sorunları önleyebilirsiniz:

    foo = +document.getElementById("foo-input").value;
    //    ^ tekli + operatorü sağ taraftaki işleneni bir sayıya çevirecektir

    // typeof foo;
    // "number"

    if ( foo === 1 ) {

      importantTask();

    }

    // `importantTask()` çağırılır
    ```

    İşte zorlamalarla birlikte bazı yaygın durumlar:


    ```javascript

    // 3.B.2.1

    var number = 1,
      string = "1",
      bool = false;

    number;
    // 1

    number + "";
    // "1"

    string;
    // "1"

    +string;
    // 1

    +string++;
    // 1

    string;
    // 2

    bool;
    // false

    +bool;
    // 0

    bool + "";
    // "false"
    ```


    ```javascript
    // 3.B.2.2

    var number = 1,
      string = "1",
      bool = true;

    string === number;
    // false

    string === number + "";
    // true

    +string === number;
    // true

    bool === number;
    // false

    +bool === number;
    // true

    bool === string;
    // false

    bool === !!string;
    // true
    ```

    ```javascript
    // 3.B.2.3

    var array = [ "a", "b", "c" ];

    !!~array.indexOf("a");
    // true

    !!~array.indexOf("b");
    // true

    !!~array.indexOf("c");
    // true

    !!~array.indexOf("d");
    // false

    // Yukarıdakilerin "gereksiz yere akıllıca" olarak kabul edilmesi gerektiğini unutmayın.
    // indexOf'un döndürülen değerini karşılaştırmanın bariz yaklaşımını tercih edin
    // örneğin:

    if ( array.indexOf( "a" ) >= 0 ) {
      // ...
    }
    ```

    ```javascript
    // 3.B.2.4


    var num = 2.5;

    parseInt( num, 10 );

    // aynı şekilde...

    ~~num;

    num >> 0;

    num >>> 0;

    // Hepsi 2 ile sonuçlanıyor


    // Ancak, negatif sayıların farklı şekilde ele alınacağını unutmayın....

    var neg = -2.5;

    parseInt( neg, 10 );

    // aynı şekilde...

    ~~neg;

    neg >> 0;

    // Hepsi -2 ile sonuçlanıyor
    // Ancak...

    neg >>> 0;

    // Bu 4294967294 ile sonuçlanacaktır




    ```



4. <a name="cond">Koşullu Değerlendirme</a>

    ```javascript

    // 4.1.1
    // Yalnızca bir dizinin uzunluğu olduğunu değerlendirirken,
    // bunun yerine:
    if ( array.length > 0 ) ...

    // ...doğruluğunu değerlendir, böyle:
    if ( array.length ) ...


    // 4.1.2
    // Yalnızca bir dizinin boş olduğunu değerlendirirken,
    // bunun yerine:
    if ( array.length === 0 ) ...

    // ...doğruluğunu değerlendir, böyle:
    if ( !array.length ) ...


    // 4.1.3
    // Yalnızca bir stringin boş olmadığını değerlendirirken,
    // bunun yerine:
    if ( string !== "" ) ...

    // ...doğruluğunu değerlendir, böyle:
    if ( string ) ...


    // 4.1.4
    // Yalnızca bir stringin boş _olduğunu_ değerlendirirken,
    // bunun yerine:
    if ( string === "" ) ...

    // ...doğruluğu değerlendir, böyle:
    if ( !string ) ...


    // 4.1.5
    // Yalnızca bir referansın doğru olduğunu değerlendirirken,
    // bunun yerine:
    if ( foo === true ) ...

    // ...sorgulamak istediğiniz şekilde değerlendirin, build in'lerden yararlanın:
    if ( foo ) ...


    // 4.1.6
    // Bir referansın yanlış olduğunu değerlendirirken,
    // bunun yerine:
    if ( foo === false ) ...

    // ...gerçek bir değerlendirmeyi zorlamak için olumsuzlamayı '!' kullanın
    if ( !foo ) ...

    // ...Dikkatli olun, bu aynı zamanda 0, "", null, undefined, NaN ile de eşleşecektir.
    // Bir boolean'ı false için test etmeniz _ZORUNLU_ysa, bunu kullanın:
    if ( foo === false ) ...


    // 4.1.7
    // Yalnızca bir referansın false, "" veya 0 DEĞİL, null veya undefined olduğunu değerlendirirken,
    // bunun yerine:
    if ( foo === null || foo === undefined ) ...

    // ..."==" operatöründen yararlanın, bunun gibi:
    if ( foo == null ) ...

    // Unutmayın, "==" kullanmak `null`'u HEM `null` ile HEM DE `undefined` ile eşleştirecektir
    // ama `false`, "" veya 0 ile değil
    null == undefined

    ```
    HER ZAMAN en iyi, en doğru sonuç için değerlendirin - yukarıdakiler bir dogma değil, bir kılavuzdur.

    ```javascript

    // 4.2.1
    // Yazım koşullama ve değerlendirme notları

    // `==` yerine `===` tercih edin (durum gevşek tip değerlendirmesi gerektirmedikçe)

    // === değişken tiplerini kontrol eder, yani:

    "1" === 1;
    // false

    // == değişken tiplerini kontrol etmez, yani

    "1" == 1;
    // true


    // 4.2.2
    // Booleanlar, True & False

    // Booleanlar:
    true, false

    // True:
    "foo", 1

    // False:
    "", 0, null, undefined, NaN, void 0

    ```


5. <a name="practical">Pratik Stil</a>

    ```javascript

    // 5.1.1
    // Pratik Bir Modül

    (function( global ) {
      var Module = (function() {

        var data = "secret";

        return {
          // Bu bir boolean değeri
          bool: true,
          // Bir string değeri
          string: "a string",
          // Bir array değeri
          array: [ 1, 2, 3, 4 ],
          // Bir obje değeri
          object: {
            lang: "tr-TR"
          },
          getData: function() {
            // `data`'nın güncel değerini elde et
            return data;
          },
          setData: function( value ) {
            // `data` değerini tanımla ve döndür
            return ( data = value );
          }
        };
      })();

      // Burada başka şeyler olabilir

      // modülümüzü global değişkene tanımlayalım
      global.Module = Module;

    })( this );

    ```

    ```javascript

    // 5.2.1
    // Pratik Bir Constructor

    (function( global ) {

      function Ctor( foo ) {

        this.foo = foo;

        return this;
      }

      Ctor.prototype.getFoo = function() {
        return this.foo;
      };

      Ctor.prototype.setFoo = function( val ) {
        return ( this.foo = val );
      };


      // Constructor'ı `new` olmadan çağırmak için, bunu yapabilirsiniz:
      var ctor = function( foo ) {
        return new Ctor( foo );
      };


      // constructor'ımızı global değişkene tanımlayalım
      global.ctor = ctor;

    })( this );

    ```



6. <a name="naming">İsimlendirme</a>



    A. Siz bir insan kod derleyicisi/kompresörü değilsiniz, bu yüzden olmaya çalışmayın.

    Aşağıdaki kod, korkunç bir isimlendirme örneğidir:

    ```javascript

    // 6.A.1.1
    // Kötü isimlere sahip kod örneği

    function q(s) {
      return document.querySelectorAll(s);
    }
    var i,a=[],els=q("#foo");
    for(i=0;i<els.length;i++){a.push(els[i]);}
    ```

    Şüphesiz, böyle bir kod yazdınız - umarım bugün son bulur.

    İşte aynı mantık parçası, ancak daha nazik, daha düşünceli bir isimlendirme (ve okunabilir bir yapıya sahip):

    ```javascript

    // 6.A.2.1
    // Geliştirilmiş isimlere sahip kod örneği

    function query( selector ) {
      return document.querySelectorAll( selector );
    }

    var idx = 0,
      elements = [],
      matches = query("#foo"),
      length = matches.length;

    for ( ; idx < length; idx++ ) {
      elements.push( matches[ idx ] );
    }

    ```

    Birkaç ek isimlendirme işaretçisi:

    ```javascript

    // 6.A.3.1
    // Stringleri isimlendirme

    `dog` bir string


    // 6.A.3.2
    // Arrayleri isimlendirme

    `dogs` bir `dog` stringleri dizisi


    // 6.A.3.3
    // Fonksiyon, obje, örnek vs isimlendirme

    camelCase; function ve değişken tanımlamaları


    // 6.A.3.4
    // Constructor, prototip vs isimlendirme

    PascalCase; constructor function


    // 6.A.3.5
    // Normal ifadeleri isimlendirme

    rDesc = //;


    // 6.A.3.6
    // Google Closure Library Style Guide'dan

    fonksiyonIsimleriBoyle;
    degiskenIsimleriBoyle;
    ConstructorIsimleriBoyle;
    EnumIsimleriBoyle;
    metodIsimleriBoyle;
    SYMBOLIC_CONSTANTS_BOYLE;

    ```

    B. `this` yüzleri

    Genel olarak iyi bilinen `call` ve `apply` kullanım durumlarının ötesinde, daha sonraki çağrılar için `BoundFunction` tanımları oluşturmak için her zaman `.bind( this )` veya işlevsel bir eşdeğerini tercih edin. Takma isim kullanmaya yalnızca tercih edilen bir seçenek olmadığında başvurun.

    ```javascript

    // 6.B.1
    function Device( opts ) {

      this.value = null;

      // bir async stream açın,
      // bu devamlı olarak çağırılacaktır
      stream.read( opts.path, function( data ) {

        // Bu örneğin mevcut değerini veri akışındaki en son değerle güncelleyin
        this.value = data;

      }.bind(this) );

      // Bu Device örneğinden çağırılan olayların sıklığını azaltın
      setInterval(function() {

        // Kısıtlanmış bir olay emit edin
        this.emit("event");

      }.bind(this), opts.freq || 100 );
    }

    // EventEmitter'ı inherit ettiğimizi varsayın ;)

    ```

    Kullanılamadığında, birçok modern JavaScript kitaplığında `.bind` işlevinin işlevsel eşdeğerleri bulunur.


    ```javascript
    // 6.B.2

    // lodash/alt çizgi, _.bind() örnekleri
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, _.bind(function( data ) {

        this.value = data;

      }, this) );

      setInterval(_.bind(function() {

        this.emit("event");

      }, this), opts.freq || 100 );
    }

    // jQuery.proxy örnekleri
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, jQuery.proxy(function( data ) {

        this.value = data;

      }, this) );

      setInterval( jQuery.proxy(function() {

        this.emit("event");

      }, this), opts.freq || 100 );
    }

    // dojo.hitch örnekleri
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, dojo.hitch( this, function( data ) {

        this.value = data;

      }) );

      setInterval( dojo.hitch( this, function() {

        this.emit("event");

      }), opts.freq || 100 );
    }

    ```

    Son çare olarak, Tanımlayıcı olarak `self`i kullanarak `this` için bir takma isim oluşturun. Bu son derece hata eğilimlidir ve mümkün olduğunca kaçınılmalıdır.

    ```javascript

    // 6.B.3

    function Device( opts ) {
      var self = this;

      this.value = null;

      stream.read( opts.path, function( data ) {

        self.value = data;

      });

      setInterval(function() {

        self.emit("event");

      }, opts.freq || 100 );
    }

    ```


    C. `thisArg` kullanın

    ES 5.1 builtin'lerinin birkaç prototip yöntemi, mümkün olduğunda kullanılması gereken özel bir `thisArg` işaretiyle birlikte gelir.

    ```javascript

    // 6.C.1

    var obj;

    obj = { f: "foo", b: "bar", q: "qux" };

    Object.keys( obj ).forEach(function( key ) {

      // |this| şimdi `obj`'i referans gösterir

      console.log( this[ key ] );

    }, obj ); // <-- son argüman `thisArg`

    // Yazdırır...

    // "foo"
    // "bar"
    // "qux"

    ```

    `thisArg` ifadesi `Array.prototype.every`, `Array.prototype.forEach`, `Array.prototype.some`, `Array.prototype.map`, `Array.prototype.filter` ile kullanılabilir

7. <a name="misc">Çeşitli</a>

    Bu bölüm, dogma olarak kabul edilmemesi gereken fikirleri ve kavramları göstermeye hizmet edecek, bunun yerine ortak JavaScript programlama görevlerini yapmanın daha iyi yollarını bulmaya yönelik sorgulama uygulamalarını teşvik etmek için var olacaktır.

    A. `switch` kullanılmaktan kaçınılmalı, modern method takibi switch ifadesi içeren fonksiyonları kara listeye alacaktır

    Firefox ve Chrome'un son sürümlerinde `switch` ifadelerinin yürütülmesinde önemli gelişmeler var gibi görünüyor.
    http://jsperf.com/switch-vs-object-literal-vs-module

    Burada da kayda değer gelişmeler görülebilir:
    https://github.com/rwldrn/idiomatic.js/issues/13

    ```javascript

    // 7.A.1.1
    // Bir switch ifadesi öreği

    switch( foo ) {
      case "alpha":
        alpha();
        break;
      case "beta":
        beta();
        break;
      default:
        // varsayılan olarak
        break;
    }

    // 7.A.1.2
    // Birleştirilebilirliği ve yeniden kullanılabilirliği destekleyen alternatif bir yaklaşım, 
    // "cases" depolamak için bir nesne ve temsilci tanımlamak için bir fonksiyon kullanmaktır:

    var cases, delegator;

    // Example returns for illustration only.
    cases = {
      alpha: function() {
        // ifadeler
        // bir return
        return [ "Alpha", arguments.length ];
      },
      beta: function() {
        // ifadeler
        // bir return
        return [ "Beta", arguments.length ];
      },
      _default: function() {
        // ifadeler
        // bir return
        return [ "Default", arguments.length ];
      }
    };

    delegator = function() {
      var args, key, delegate;

      // Argüman list'ini bir arraye çevirir
      args = [].slice.call( arguments );

      // case anahtarını argümanlardan karıştırır
      key = args.shift();

      // Varsayılan case handler'ı tanımlayın
      delegate = cases._default;

      // İşlemi devretme yöntemini oluştur
      if ( cases.hasOwnProperty( key ) ) {
        delegate = cases[ key ];
      }

      // arg kapsamı belirli bir şeye ayarlanabilir,
      // bu durumda |null| yeterli olur
      return delegate.apply( null, args );
    };

    // 7.A.1.3
    // API'yi 7.A.1.2'de çalıştırın:

    delegator( "alpha", 1, 2, 3, 4, 5 );
    // [ "Alpha", 5 ]

    // Elbette, `case` anahtar argümanı 
    // kolaylıkla başka bir keyfi koşula dayandırılabilir.

    var caseKey, someUserInput;

    // Muhtemelen bir tür form girdisi?
    someUserInput = 9;

    if ( someUserInput > 10 ) {
      caseKey = "alpha";
    } else {
      caseKey = "beta";
    }

    // veya...

    caseKey = someUserInput > 10 ? "alpha" : "beta";

    // Ve daha sonra...

    delegator( caseKey, someUserInput );
    // [ "Beta", 1 ]

    // Ve tabi ki...

    delegator();
    // [ "Default", 0 ]


    ```

    B. Erken döndürmeler, ihmal edilebilir performans farkıyla kod okunabilirliğini artırır

    ```javascript

    // 7.B.1.1
    // Kötü:
    function returnLate( foo ) {
      var ret;

      if ( foo ) {
        ret = "foo";
      } else {
        ret = "quux";
      }
      return ret;
    }

    // İyi:

    function returnEarly( foo ) {

      if ( foo ) {
        return "foo";
      }
      return "quux";
    }

    ```


8. <a name="native">Yerel ve Ana Nesneler</a>

    Buradaki temel ilke şudur:

    ### Aptalca şeyler yapmazsan her şey yolunda olur.

    Bu konsepti güçlendirmek için lütfen aşağıdaki sunumu izleyin:

    #### “Her Şey Serbest: Built-in'leri Genişletmek” -Andrew Dupont (JSConf2011, Portland, Oregon)

    [Andrew Dupont: Everything is Permitted: Extending Built-ins](https://www.youtube.com/watch?v=xL3xCO7CLNM)


9. <a name="comments">Yorumlar</a>

    #### Konu olan kodun üstündeki tek satır
    #### Çoklu satır iyidir
    #### Satır sonu yorumları yasaktır!
    #### JSDoc stili iyidir, ancak önemli bir zaman yatırımı gerektirir


10. <a name="language">Tek Dil Kod</a>

    Programlar, bu dil ne olursa olsun, yazan veya yazanlar tarafından belirtildiği gibi tek bir dilde yazılmalıdır.

## Ek Bölüm

### Önce Virgül.

Any project that cites this document as its base style guide will not accept comma first code formatting, unless explicitly specified otherwise by that project's author.



----------


<a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Principles of Writing Consistent, Idiomatic JavaScript</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/rwldrn/idiomatic.js" property="cc:attributionName" rel="cc:attributionURL">Rick Waldron and Contributors</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/rwldrn/idiomatic.js" rel="dct:source">github.com/rwldrn/idiomatic.js</a>.
