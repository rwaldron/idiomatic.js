# Принципи на консистентно и идиоматично писане на JavaScript

## Това е "жив" документ и нови идеи за подобряване на кода са винаги добре дошли. Допринесете: fork, clone, branch, commit, push, pull request.

* Rick Waldron [@rwaldron](http://twitter.com/rwaldron), [github](https://github.com/rwaldron)
* Mathias Bynens [@mathias](http://twitter.com/mathias), [github](https://github.com/mathiasbynens)
* Schalk Neethling [@ossreleasefeed](http://twitter.com/ossreleasefeed), [github](https://github.com/ossreleasefeed/)
* Kit Cambridge  [@kitcambridge](http://twitter.com/kitcambridge), [github](https://github.com/kitcambridge)
* Raynos  [github](https://github.com/Raynos)
* Matias Arriola [@MatiasArriola](https://twitter.com/MatiasArriola), [github](https://github.com/MatiasArriola/)
* John Fischer [@jfroffice](https://twitter.com/jfroffice), [github](https://github.com/jfroffice/)
* Idan Gazit [@idangazit](http://twitter.com/idangazit), [github](https://github.com/idan)
* Leo Balter [@leobalter](http://twitter.com/leobalter), [github](https://github.com/leobalter)
* Breno Oliveira [@garu_rj](http://twitter.com/garu_rj), [github](https://github.com/garu)
* Leo Beto Souza [@leobetosouza](http://twitter.com/leobetosouza), [github](https://github.com/leobetosouza)
* Ryuichi Okumura [@okuryu](http://twitter.com/okuryu), [github](https://github.com/okuryu)
* Pascal Precht [@PascalPrecht](http://twitter.com/PascalPrecht), [github](https://github.com/pascalprecht)
* EngForDev [engfordev](https://opentutorials.org/course/245/1788) - Hwan Min Hong / MinTaek Kwon [@leoinsight](http://twitter.com/leoinsight) / Tw Shim [@marocchino](http://twitter.com/marocchino), [github](https://github.com/marocchino) / Nassol Kim [@nassol99](http://twitter.com/nassol99), [github](https://github.com/nassol) / Juntai Park [@rkJun](http://twitter.com/rkJun), [github](https://github.com/rkJun) / Minkyu Shim / Gangmin Won / Justin Yoo [@justinchronicle](http://twitter.com/justinchronicle) / Daeyup Lee
* Marco Trulla [@marcotrulla](http://twitter.com/marcotrulla), [github](https://github.com/Ragnarokkr)
* Alex Navasardyan [@alexnavasardyan](http://twitter.com/alexnavasardyan), [github](https://github.com/2k00l)
* Mihai Paun [@mihaipaun](http://twitter.com/mihaipaun), [github](https://github.com/mihaipaun)
* Evgeny Mandrikov [@\_godin\_](http://twitter.com/_godin_), [github](https://github.com/Godin)
* Sofish Lin [@sofish](http://twitter.com/sofish), [github](https://github.com/sofish)
* Дејан Димић [@dejan_dimic](http://twitter.com/dejan_dimic), [github](https://github.com/rubystream)
* Miloš Gavrilović [@gavrisimo](http://twitter.com/gavrisimo), [github](https://github.com/gavrisimo)
* Firede [@firede](https://twitter.com/firede) [github](https://github.com/firede)
* monkadd [github](https://github.com/monkadd)
* Stephan Lindauer [@stephanlindauer](http://twitter.com/stephanlindauer), [github](https://github.com/stephanlindauer)
* Thomas P [@dragon5689](https://twitter.com/dragon5689) [github](https://github.com/dragon5689)
* Yotam Ofek [@yotamofek](https://twitter.com/yotamofek) [github](https://github.com/yotamofek)
* Aleksandr Filatov [@greybax](http://twitter.com/greybax), [github](https://github.com/greybax)
* Duc Nguyen [@ducntq](https://twitter.com/ducntq), [github](https://github.com/ducntq)
* James Young [@jamsyoung](http://twitter.com/jamsyoung), [github](https://github.com/jamsyoung)
* Hao-Wei Jeng [@l0ckys](http://twitter.com/l0ckys), [github](https://github.com/lockys)  
* Richard Gibson [@gibson042](http://twitter.com/gibson042), [github](https://github.com/gibson042)  
* Fesuy [github](https://github.com/fesuydev)  
* Stephane Moreau [github](https://github.com/stmoreau)  
* Boris Nekezov [github](https://github.com/boris-nekezov)  
* Akshat Joshi [@akshat_joshi](http://twitter.com/akshat_joshi), [github](https://https://github.com/akshatjoshii)

## Целият код във всяка кодова база трябва да изглежда като писано от един човек, няма значение колко души са допринесли.

### Последващия списък изтъква практиките, които използвам в всичкия ми код, на който съм оригинален автор; участия в проекти, които съм създал трябва да следват тези напътствия.

### Нямам намерение да налагам моите предпочитания за стил на кода или проекти на други хора; ако има наличие на съществуващ общ стил, той трябва да се спазва.

> ### "Спорове за стилове са безсмислени. Трябва да има ръководство за стила и трябва да го спазвате"
>_Rebecca_ _Murphey_

&nbsp;

> ### "Част от това да си добър ръководител на един успешен проект е да осъзнаете, че писането на код за вас е лоша идея. Ако хиляди души използват вашия код, тогава пишете кода ви максилнално ясно, а не по вашето лично предпочитание."
>_Idan_ _Gazit_


## Translations

* [ORIGINAL](https://github.com/rwldrn/idiomatic.js/)
* [Bulgarian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/bg_BG)
* [German](https://github.com/rwldrn/idiomatic.js/tree/master/translations/de_DE)
* [French](https://github.com/rwldrn/idiomatic.js/tree/master/translations/fr_FR)
* [Spanish](https://github.com/rwldrn/idiomatic.js/tree/master/translations/es_ES)
* [Portuguese - Brazil](https://github.com/rwldrn/idiomatic.js/tree/master/translations/pt_BR)
* [Korean](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ko_KR)
* [日本語](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ja_JP)
* [Italian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/it_IT)
* [Russian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ru_RU)
* [Romanian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ro_RO)
* [简体中文](https://github.com/rwldrn/idiomatic.js/tree/master/translations/zh_CN)
* [Serbian - cyrilic alphabet](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ср_СР)
* [Serbian - latin alphabet](https://github.com/rwldrn/idiomatic.js/tree/master/translations/sr_SR)
* [繁體中文](https://github.com/rwaldron/idiomatic.js/tree/master/translations/zh_TW)  
* [Indonesian](https://github.com/rwaldron/idiomatic.js/tree/master/translations/id_ID)  
* [Greek](https://github.com/rwaldron/idiomatic.js/tree/master/translations/gr_GR)  
* [Hindi](https://github.com/rwaldron/idiomatic.js/tree/master/translations/hi_HI)

## Важни, Не-Идиоматични Неща:

### Инструменти за Качество на Кода, Ресурси & Референции

 * [JavaScript Plugin](http://docs.codehaus.org/display/SONAR/JavaScript+Plugin) for [Sonar](http://www.sonarsource.org/)
 * [Plato](https://github.com/es-analysis/plato)
 * [jsPerf](http://jsperf.com/)
 * [jsFiddle](http://jsfiddle.net/)
 * [Codepen](http://codepen.io/)
 * [jsbin](http://jsbin.com/)
 * [JavaScript Lint (JSL)](http://javascriptlint.com/)
 * [jshint](http://jshint.com/)
 * [jslint](http://jslint.org/)
 * [eslint](http://eslint.org/)
 * [jscs](https://www.npmjs.org/package/jscs)
 * [jscodesniffer](https://www.npmjs.org/package/jscodesniffer)
 * [Editorconfig](http://editorconfig.org/)
 * [Hound](https://houndci.com/)

## Станете Умни

### [Annotated ECMAScript 5.1](http://es5.github.com/)
### [Спецификация на Езика EcmaScript, Издание 5.1](http://ecma-international.org/ecma-262/5.1/)

Последващото трябва да се вземе под внимание 1) недовършено, и 2) *ИЗИСКВА СЕ ЧЕТЕНЕ*. Не винаги съм съгласен със стила написан от авторите по-долу, но едно нещо е сигурно: Те са консистентни. Нещо повече, това са авторитети на езика.

 * [Baseline For Front End Developers: 2015](http://rmurphey.com/blog/2015/03/23/a-baseline-for-front-end-developers-2015/)
 * [Eloquent JavaScript](http://eloquentjavascript.net/)
 * [JavaScript, JavaScript](http://javascriptweblog.wordpress.com/)
 * [Adventures in JavaScript Development](http://rmurphey.com/)
 * [Perfection Kills](http://perfectionkills.com/)
 * [Douglas Crockford's Wrrrld Wide Web](http://www.crockford.com)
 * [JS Assessment](https://github.com/rmurphey/js-assessment)

### Процес на компилация и деплойване

Проектите винаги трябва да включат някои общи средства, чрез които източникът да бъде свързан, тестван и компресиран при подготовка за производствена употреба. За тази задача, [grunt](https://github.com/gruntjs/grunt) на Бен Алман е най-добрата от всички официални заместители на папката "kits/" в това хранилище.

### Тестова база

Проектите трябва да включват някаква форма на единица, референция, имплементация или функционално тестване. Демострационни случаи на употреба НЕ СЕ КВАЛИФИЦИРАТ като "тестове". По-долу има списък със тестови рамки, нито една от които не е одобрена повече от другата.

 * [QUnit](http://github.com/jquery/qunit)
 * [Jasmine](https://github.com/pivotal/jasmine)
 * [Vows](https://github.com/cloudhead/vows)
 * [Mocha](https://github.com/visionmedia/mocha)
 * [Hiro](http://hirojs.com/)
 * [JsTestDriver](https://code.google.com/p/js-test-driver/)
 * [Buster.js](http://busterjs.org/)
 * [Sinon.js](http://sinonjs.org/)
 * [Tape](https://github.com/substack/tape)
 * [Jest](https://facebook.github.io/jest/)

## Съдържание

 * [Whitespace](#whitespace)
 * [Beautiful Syntax](#spacing)
 * [Type Checking (Courtesy jQuery Core Style Guidelines)](#type)
 * [Conditional Evaluation](#cond)
 * [Practical Style](#practical)
 * [Naming](#naming)
 * [Misc](#misc)
 * [Native & Host Objects](#native)
 * [Comments](#comments)
 * [One Language Code](#language)



------------------------------------------------


## Предговор

Следващите раздели посочват едно разумно ръководство на стил за съвременна разработка на JavaScript и не е предназначен за норматив. Най-важната част е **закона за постоянност на стила на кода**. Каквото и да изберете като стил за вашия проект, трябва да се счита за закон. Използвайте този документ като напътствие на вашето отдаване към проекта ви за консистентност на стила на кода, четимост и поддържане. 

## Манифест на идиоматичния стил


1. <a name="whitespace">Празно пространство</a>
  - Никога не смесвайте спейсове и табове.
  - Когато започнете един проект, преди да почнете да пишете какъвто и да е код, изберете между меки отсъпи (интервали) или реални табулации, считайте го за **закон**
      - За четимост, винаги препоръчвам да зададете размера на отстъпа на вашия редактор на два знака &mdash; което означава два интервала или два интервала, представляващи истинска табулация.
  - Винаги работете с включена настройка "покажи скрити", ако редактора ви я поддържа. Предимствата на тази практика са:
      - Усилена консистенция
      - Премахване на интервал в края на реда
      - Премахване на празни редове
      - Комитите и разликите в кода са по-лесни за четене
  - Използвайте [Editorconfig](http://editorconfig.org/) когато е възможно. Поддържа повечето IDEs и обработва повечето настройки за празно пространство.

2. <a name="spacing">Красив синтаксис</a>

    A. Parens, Braces, Linebreaks
    А. Скоби, Фигурни Скоби, Пренасяне на редовете

    ```javascript

    // if/else/for/while/try винаги имат интервали между тях, къдравите скоби и разделението между секциите са на множество редове
    // това подобрява четимостта

    // 2.A.1.1
    // Примери за наистина нечетлив синтаксис

    if(condition) doSomething();

    while(condition) iterating++;

    for(var i=0;i<100;i++) someIterativeFn();


    // 2.A.1.1
    // Използвайте интервали за да повишите четимостта

    if ( condition ) {
      // изрази
    }

    while ( condition ) {
      // изрази
    }

    for ( var i = 0; i < 100; i++ ) {
      // изрази
    }

    // Още по-добре:

    var i,
      length = 100;

    for ( i = 0; i < length; i++ ) {
      // изрази
    }

    // Или...

    var i = 0,
      length = 100;

    for ( ; i < length; i++ ) {
      // изрази
    }

    var prop;

    for ( prop in object ) {
      // изрази
    }


    if ( true ) {
      // изрази
    } else {
      // изрази
    }
    ```

    B. Прислояване, Декларации, Функции ( Именувани, Изрази, Конструктори)
    ```javascript

    // 2.B.1.1
    // Променливи
    var foo = "bar",
      num = 1,
      undef;

    // Литерална нотация:
    var array = [],
      object = {};


    // 2.B.1.2
    // Използването на само един `var` на всеки обхват (функция) или по един `var` на всяка променлива,
    // повишава четимостта и пази вашия списък на декларации от безредие.
    // Използването по един `var` на всяка променлива можете да контролирате по-добре версиите 
    // и освен това улеснява разместването на редовете.
    // Един `var` на всеки обхват улеснява намирането на недекларирани променливи,
    // които могат да станат подразбиращи се глобални.
    // Изберете по-добрия подход за вашия проект и никога не го смесвайте

    // Лош пример
    var foo = "",
      bar = "";
    var qux;

    // Добър пример
    var foo = "";
    var bar = "";
    var qux;

    // или..
    var foo = "",
      bar = "",
      qux;

    // или..
    var // Коментар на тези
    foo = "",
    bar = "",
    quux;

    // 2.B.1.3
    // Операторите 'var' винаги трябва да са в началото на техния съответен обxват (функция).

    // Лош пример
    function foo() {

      // някакви изрази

      var bar = "",
        qux;
    }

    // Добър пример
    function foo() {
      var bar = "",
        qux;

      // всички изрази след декларацията на променливите
    }

    // 2.B.1.4
    // 'const' и `let`, от ECMAScript 6, също трябва да са в горната част на техния обхват (блоков).

    // Лош пример
    function foo() {
      let foo,
        bar;
      if ( condition ) {
        bar = "";
        // изрази
      }
    }
    // Добър пример
    function foo() {
      let foo;
      if ( condition ) {
        let bar = "";
        // изрази
      }
    }
    ```

    ```javascript

    // 2.B.2.1
    // Деклариране на именувана функция
    function foo( arg1, argN ) {

    }

    // Използване 
    foo( arg1, argN );


    // 2.B.2.2
    // Деклариране на именувана функция
    function square( number ) {
      return number * number;
    }

    // Използване
    square( 10 );

    // Много измислен стил на подаване на параметри
    function square( number, callback ) {
      callback( number * number );
    }

    square( 10, function( square ) {
      // изрази с обратно извикване
    });


    // 2.B.2.3
    // Функция-Израз
    var square = function( number ) {
      // Върнете нещо важно и релевантно
      return number * number;
    };

    // Функция-Израз с Идентификатор
    // Тази предпочитана форма има добавената стойност
    // и името му ще бъде видимо в стека на функционалните обаждания:
    var factorial = function factorial( number ) {
      if ( number < 2 ) {
        return 1;
      }

      return number * factorial( number - 1 );
    };


    // 2.B.2.4
    // Деклариране на Конструктор
    function FooBar( options ) {

      this.options = options;
    }

    // Използване
    var fooBar = new FooBar({ a: "alpha" });

    fooBar.options;
    // { a: "alpha" }

    ```


    C. Изключения, леки отклонения

    ```javascript

    // 2.C.1.1
    // Функции с обратно извикване
    foo(function() {
      // Забележете, че няма интервали между първата скоба
      // на изпълненото фунционално извикване и думата "function"
    });

    // Функция приемаща масив като параметър, без интервал
    foo([ "alpha", "beta" ]);

    // 2.C.1.2
    // Функция приемаща обект като параметър, без интервал
    foo({
      a: "alpha",
      b: "beta"
    });

    // Единичен низ като параметър, също без интервал
    foo("bar");

    // Съдържание във вътрешни скоби, също без интервал
    if ( !("foo" in obj) ) {
      obj = (obj.bar || defaults).baz;
    }

    ```

    D. Консистентността винаги побеждава

    В секции 2.A-2.C, правилата за интервали са изложени като препоръка с по-проста и по-извисена цел: консистентност.
    Важно е да се отбележи, че предпочитанията за форматиране, такива като "вътрешно пространство", трябва да се считат за незадължителни, но само един стил трябва да съществува из целия код на вашия проект.

    ```javascript

    // 2.D.1.1

    if (condition) {
      // изрази
    }

    while (condition) {
      // изрази
    }

    for (var i = 0; i < 100; i++) {
      // изрази
    }

    if (true) {
      // изрази
    } else {
      // изрази
    }

    ```

    E. Кавички

    Независимо от това дали предпочитате единични или двойни кавички, няма разлика в това как JavaScript ги парсва. Това което **АБСОЛЮТНО ТРЯБВА** да се наложи е консистентност. **Никога не смесвайте кавичките в един и същи проект. Изберете един стил и се придържайте към него.**

    F. Край на Редовете и Празни Редове

    Пространствата могат да развалят разликите и да направят промените невъзможни за четене. Помислете да включите "pre-commit" кука, която да премахне автоматично пространството на края на реда и празните пространства на редовете.


3. <a name="type">Type Checking (Courtesy jQuery Core Style Guidelines)</a>

    A. Типове

    String:

        typeof variable === "string"

    Number:

        typeof variable === "number"

    Boolean:

        typeof variable === "boolean"

    Object:

        typeof variable === "object"

    Array:

        Array.isArray( arrayLikeObject )
        (wherever possible)

    Node:

        elem.nodeType === 1

    null:

        variable === null

    null or undefined:

        variable == null

    undefined:

      Глобални променливи:

        typeof variable === "undefined"

      Локални променливи:

        variable === undefined

      Свойства:

        object.prop === undefined
        object.hasOwnProperty( prop )
        "prop" in object

    B. Прехвърляне на Типове

    Представете си следното...

    Даден ви е следния HTML:

    ```html

    <input type="text" id="foo-input" value="1">

    ```


    ```javascript

    // 3.B.1.1

    // `foo` е деклариран със стойност `0` и неговия тип е `number`
    var foo = 0;

    // typeof foo;
    // "number"
    ...

    // Някъде по-късно във вашия код, трябва да обновите `foo`
    // с нова стойност взета от елемента 'input'

    foo = document.getElementById("foo-input").value;

    // Ако сега тествате 'typeof foo`, резултатът ще бъде 'string' 
    // Това означава, че ако имате логика, която тества 'foo' като тази:
    if ( foo === 1 ) {

      importantTask();

    }

    // `importantTask()` няма никога да бъде достигнат дори и `foo` да има стойност "1"

    // 3.B.1.2

    // Можете да избегнете проблеми като използвате умно конвертиране в унарните оператори + и -:

    foo = +document.getElementById("foo-input").value;
    //    ^ унарния оператор + ще преобразува десния си операнд в тип 'number'

    // typeof foo;
    // "number"

    if ( foo === 1 ) {

      importantTask();

    }

    // `importantTask()` ще бъде извикана
    ```

    Ето няколко често срещани примера за прехвърляне на типове:


    ```javascript

    // 3.B.2.1

    var number = 1,
      string = "1",
      bool = false;

    number;
    // 1

    number + "";
    // "1"

    string;
    // "1"

    +string;
    // 1

    +string++;
    // 1

    string;
    // 2

    bool;
    // false

    +bool;
    // 0

    bool + "";
    // "false"
    ```


    ```javascript
    // 3.B.2.2

    var number = 1,
      string = "1",
      bool = true;

    string === number;
    // false

    string === number + "";
    // true

    +string === number;
    // true

    bool === number;
    // false

    +bool === number;
    // true

    bool === string;
    // false

    bool === !!string;
    // true
    ```

    ```javascript
    // 3.B.2.3

    var array = [ "a", "b", "c" ];

    !!~array.indexOf("a");
    // true

    !!~array.indexOf("b");
    // true

    !!~array.indexOf("c");
    // true

    !!~array.indexOf("d");
    // false

    // Забележете, че горните примери може да се считат за "ненужно умни"
    // За предпочитане е очевидния подход да сравнявате върнатата стойност на
    // indexOf, по този начин:

    if ( array.indexOf( "a" ) >= 0 ) {
      // ...
    }
    ```

    ```javascript
    // 3.B.2.4


    var num = 2.5;

    parseInt( num, 10 );

    // е съшото като ...

    ~~num;

    num >> 0;

    num >>> 0;

    // Във всички случаи резултатът е равен на 2


    // Помнете, че отрицателните числа ще бъдат обработени различно ...

    var neg = -2.5;

    parseInt( neg, 10 );

    // е същото като...

    ~~neg;

    neg >> 0;

    // Във всички случаи резултатът е равен на -2
    // Въпреки че при...

    neg >>> 0;

    // Резултата ще е 4294967294




    ```



4. <a name="cond">Условна Проверка</a>

    ```javascript

    // 4.1.1
    // Проверете дали масивът има дължина,
    // вместо:
    if ( array.length > 0 ) ...

    // ...проверявайте за истина, по този начин:
    if ( array.length ) ...


    // 4.1.2
    // Проверете дали масива е празен,
    // вместо:
    if ( array.length === 0 ) ...

    // ...проверявайте за вярност, по този начин:
    if ( !array.length ) ...


    // 4.1.3
    // Проверете дали низа не е празен,
    // вместо:
    if ( string !== "" ) ...

    // ...проверявайте за вярност, по този начин:
    if ( string ) ...


    // 4.1.4
    // Проверете дали низа _е_ празен,
    // вместо:
    if ( string === "" ) ...

    // ...проверявайте дали израдът е неверен, по този начин:
    if ( !string ) ...


    // 4.1.5
    // Проверете дали тази референция е вярна,
    // вместо:
    if ( foo === true ) ...

    // ...проверете, възползвайки се от вградените възможности:
    if ( foo ) ...


    // 4.1.6
    // Проверете дали тази референция е невярна,
    // вместо:
    if ( foo === false ) ...

    // ...проверете, използвайки отрицание
    if ( !foo ) ...

    // ...Внимавайте, това важи и за: 0, "", null, undefined, NaN
    // Ако _трябва_ да тествате за булево невярно, тогава използвайте
    
    if ( foo === false ) ...


    // 4.1.7
    // Когато проверявате дали е null или undefined, но НЕ Е false, "" или 0,
    // вместо това:
    if ( foo === null || foo === undefined ) ...

    // ...използвайте оператора ==:
    if ( foo == null ) ...

    // Помнете, че използвайки оператора == с `null` важи И ЗА ДВЕТЕ `null` и `undefined`
    // но не `false ', "" или 0
    null == undefined

    ```
    ВИНАГИ проверявайте за най-добрия и точен резултат - горното е ръководство, не догма.

    ```javascript

    // 4.2.1
    // Преобразуване на типове и бележки за проверяване

    // За предпочитане е да използвате `===` вместо `==` (освен ако конкретния случай не изисква слабо типизирана оценка)

    // === проверява и типа, т.е.:

    "1" === 1;
    // false

    // == не проверява типа, т.е.:

    "1" == 1;
    // true


    // 4.2.2
    // Логически изрази, Вярни & Невярни

    //  Логически изрази:
    true, false

    // Вярни:
    "foo", 1

    // Невярни:
    "", 0, null, undefined, NaN, void 0

    ```


5. <a name="practical">Стил на Практика</a>

    ```javascript

    // 5.1.1
    // Практичен модул

    (function( global ) {
      var Module = (function() {

        var data = "secret";

        return {
          // Логическо свойство
          bool: true,
          // Стойност от тип низ
          string: "a string",
          // Свойство - масив
          array: [ 1, 2, 3, 4 ],
          // Свойство - обект
          object: {
            lang: "bg-BG"
          },
          getData: function() {
            // вземете текущата стойност на променливата `data`
            return data;
          },
          setData: function( value ) {
            // присвоете стойността на `data` и я върнете
            return ( data = value );
          }
        };
      })();

      // Други декларации

      // добавяме нашия модул към глобалния обект
      global.Module = Module;

    })( this );

    ```

    ```javascript

    // 5.2.1
    // Практичен Конструктор

    (function( global ) {

      function Ctor( foo ) {

        this.foo = foo;

        return this;
      }

      Ctor.prototype.getFoo = function() {
        return this.foo;
      };

      Ctor.prototype.setFoo = function( val ) {
        return ( this.foo = val );
      };


      // За да извикате конструктора без `new`, можете да направите това:
      var ctor = function( foo ) {
        return new Ctor( foo );
      };


      // добави нашия конструктор към глобалния обект
      global.ctor = ctor;

    })( this );

    ```



6. <a name="naming">Наименуване</a>



    A. Вие не сте човешки компилатор/компресор на код, затова не се опитвайте да бъдете такъв.

    Последващия код е пример за лошо именуване:

    ```javascript

    // 6.A.1.1
    // Пример за код с лоши имена

    function q(s) {
      return document.querySelectorAll(s);
    }
    var i,a=[],els=q("#foo");
    for(i=0;i<els.length;i++){a.push(els[i]);}
    ```

    Без съмнение сте писали код като този - дано това приключи днес.

    Сега същото парче логика, но с по-добро, по-смислено именуване (и четима структура):
    
    ```javascript

    // 6.A.2.1
    // Пример на кода с подобрени имена

    function query( selector ) {
      return document.querySelectorAll( selector );
    }

    var idx = 0,
      elements = [],
      matches = query("#foo"),
      length = matches.length;

    for ( ; idx < length; idx++ ) {
      elements.push( matches[ idx ] );
    }

    ```

    Още няколко съвета за именуване на променливи::

    ```javascript

    // 6.A.3.1
    // Именуване на низове

    `dog` is a string


    // 6.A.3.2
    // Именуване на масиви

    `dogs` is an array of `dog` strings


    // 6.A.3.3
    // Именуване на фукнции, обекти, инстанции, и т.н.

    camelCase; function and var declarations


    // 6.A.3.4
    // Именуване на конструктори, прототипи и т.н.
    PascalCase; constructor function


    // 6.A.3.5
    // Именуване на регулярни изрази

    rDesc = //;


    // 6.A.3.6
    // Из Ръководство по стила Google Closure Library

    functionNamesLikeThis;
    variableNamesLikeThis;
    ConstructorNamesLikeThis;
    EnumNamesLikeThis;
    methodNamesLikeThis;
    SYMBOLIC_CONSTANTS_LIKE_THIS;

    ```

    B. Лица на `this`

    Извън общоизвестните случаи на `call` и `apply`, винаги избирайте `.bind( this )` или фунционалния му еквивалент, за създаване на дефиниция `BoundFunction` за по-късно извикване. Създаването на псевдоним е в краен случай, ако други решения не са подходящи.
    
    ```javascript

    // 6.B.1
    function Device( opts ) {

      this.value = null;

      // Отворете асинхронен поток,
      // това ще се извиква продължително
      stream.read( opts.path, function( data ) {

        // Обновете текущата стойност на инстанцията
        // с последната стойност от
        // потока на данни
        this.value = data;

      }.bind(this) );

      // Ограничете честотата на събитията изпратени от
      // инстанцията на Device
      setInterval(function() {

        // Изпращане на събитие
        this.emit("event");

      }.bind(this), opts.freq || 100 );
    }

    // Просто се преструвайте, че сме наследили EventEmitter ;)

    ```

    Когато не е достъпен фукнционалния еквивалент на `.bind` съществува в много модерни JavaScript библиотеки.


    ```javascript
    // 6.B.2

    // например lodash/underscore, _.bind()
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, _.bind(function( data ) {

        this.value = data;

      }, this) );

      setInterval(_.bind(function() {

        this.emit("event");

      }, this), opts.freq || 100 );
    }

    // например jQuery.proxy
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, jQuery.proxy(function( data ) {

        this.value = data;

      }, this) );

      setInterval( jQuery.proxy(function() {

        this.emit("event");

      }, this), opts.freq || 100 );
    }

    // например dojo.hitch
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, dojo.hitch( this, function( data ) {

        this.value = data;

      }) );

      setInterval( dojo.hitch( this, function() {

        this.emit("event");

      }), opts.freq || 100 );
    }

    ```

    В краен случай, създайте алиас на `this` използвайки `self` като идентификатор. Това е изключително податливо на грешки и трябва да се избягва, когато е възможно.

    ```javascript

    // 6.B.3

    function Device( opts ) {
      var self = this;

      this.value = null;

      stream.read( opts.path, function( data ) {

        self.value = data;

      });

      setInterval(function() {

        self.emit("event");

      }, opts.freq || 100 );
    }

    ```


    C. Използване на `thisArg`

    Няколко прототипни метода вградени в ES 5.1 идват със специалния `thisArg`, който трябва да се използва когато е възможно

    ```javascript

    // 6.C.1

    var obj;

    obj = { f: "foo", b: "bar", q: "qux" };

    Object.keys( obj ).forEach(function( key ) {

      // |this| сочи към `obj`

      console.log( this[ key ] );

    }, obj ); // <-- последния аргумент е `thisArg`

    // Ще изпечата...

    // "foo"
    // "bar"
    // "qux"

    ```

    `thisArg` може да се използва `Array.prototype.every`, `Array.prototype.forEach`, `Array.prototype.some`, `Array.prototype.map`, `Array.prototype.filter`

7. <a name="misc">Разни</a>

    Този раздел ще служи за илюстриране на идеи и концепции, които не трябва да се считат за догма, вместо това съществува за да даде под съмнение практиките в опит да се намери по-добри начини за изпълнение, на често срещани JavaScript задачи.

    A. Използването на `switch` трябва да се избягва, тъй като съвременния метод за отстраняване на грешки ще скрие повикванията на функции, които го използват.

    Изглежда че последните версии на браузърите Firefox и Chrome имат значителни подобрения в работата на функциите, които използват `switch`.
    http://jsperf.com/switch-vs-object-literal-vs-module

    Забележими подобрения могат да се видят също и тук:
    https://github.com/rwldrn/idiomatic.js/issues/13

    ```javascript

    // 7.A.1.1
    // Пример на оператора switch

    switch( foo ) {
      case "alpha":
        alpha();
        break;
      case "beta":
        beta();
        break;
      default:
        // код по подразбиране
        break;
    }

    // 7.A.1.2

    // Алтернативен подход, който подкрепя използваемостта и повторната употреба е да
    // се използва обект за съхранение на "случаи" и функция за делегация
    var cases, delegator;

    // Примерът връща само с илюстративни цели.
    cases = {
      alpha: function() {
        // изрази
        // връщане
        return [ "Alpha", arguments.length ];
      },
      beta: function() {
        // изрази
        // връщане
        return [ "Beta", arguments.length ];
      },
      _default: function() {
        // изрази
        // връщане
        return [ "Default", arguments.length ];
      }
    };

    delegator = function() {
      var args, key, delegate;

      // Трансформиране на списъка с аргументите в масив
      args = [].slice.call( arguments );

      // Променяне на ключа на случая от аргументите
      key = args.shift();

      // Определяне на ключа по подразбиране
      delegate = cases._default;

      // Извличане на метода за да делегиране на операция
      if ( cases.hasOwnProperty( key ) ) {
        delegate = cases[ key ];
      }

      // Обхватния аргумент може да бъде зададен към нещо специфични,
      // в този случай, |null| ще бъде достатъчно
      return delegate.apply( null, args );
    };

    // 7.A.1.3
    // Сложете Апито в 7.A.1.2 да работи:
    delegator( "alpha", 1, 2, 3, 4, 5 );
    // [ "Alpha", 5 ]

    // Разбира се, ключовият аргумент на `случая` може да се основава лесно
    // при някакво друго произволно условие.
    var caseKey, someUserInput;

    // Вероятно някакво поле на форма?
    someUserInput = 9;

    if ( someUserInput > 10 ) {
      caseKey = "alpha";
    } else {
      caseKey = "beta";
    }

    // или...

    caseKey = someUserInput > 10 ? "alpha" : "beta";

    // И тогава...

    delegator( caseKey, someUserInput );
    // [ "Beta", 1 ]

    // И разбира се...

    delegator();
    // [ "Default", 0 ]


    ```

    B. Ранните връщания подобряват четимостта на кода с незначителна разлика в производителността

    ```javascript

    // 7.B.1.1
    // Лош пример:
    function returnLate( foo ) {
      var ret;

      if ( foo ) {
        ret = "foo";
      } else {
        ret = "quux";
      }
      return ret;
    }

    // Добър пример:

    function returnEarly( foo ) {

      if ( foo ) {
        return "foo";
      }
      return "quux";
    }

    ```


8. <a name="native">"Родни" и "Чужди" обекти</a>

    Основния принципт тук е:

    ### Не правете глупости и всичко ще бъде наред.

    За да подсилите тази концепция, моля гледайте последващата презентация:

    #### “Everything is Permitted: Extending Built-ins” от Андрю Дюпонт (JSConf2011, Портланд, Орегон)

    https://www.youtube.com/watch?v=xL3xCO7CLNM


9. <a name="comments">Коментари</a>

    #### Едноредов коментар над кода, за който е предназначен
    #### Многоредови коментари също са добре дошли
    #### Коментарите в края на реда са забранени!
    #### Стила JSDoc е добър, но изисква да се инвестира значително време

10. <a name="language">Код на Един Език </a>

    Програмите трябва да бъдат написани на един език, независимо какъв е той, както се изисква от хората, които поддържат кода.

## Приложение

### Първа Запетая.

Всеки проект, който се отнася до този документ като основно ръководство за стил, няма да приеме форматирането на кода "първа запетая", освен ако авторът на проекта конкретно не посочи това.



----------


<a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Principles of Writing Consistent, Idiomatic JavaScript</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/rwldrn/idiomatic.js" property="cc:attributionName" rel="cc:attributionURL">Rick Waldron and Contributors</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/rwldrn/idiomatic.js" rel="dct:source">github.com/rwldrn/idiomatic.js</a>.
